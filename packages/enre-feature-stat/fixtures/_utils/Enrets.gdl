// This function tries get a node's name.
// This is useful for any schema that does not provide a getNameNode method.
fn forceGetName(node: Node) -> string {
    return getPropertyNamePatched(forceGetNameNode(node))
}

fn forceGetNameNode(node: Node) -> PropertyName {
    for (childIndex in int::__undetermined_all__()) {
        let (child = node.getChild(childIndex)) {
            let (tmp = PropertyName(__all_data__).find(child)) {
                return tmp
            }
        }
    }
}

// This function additonally return '<computed>' if the property is a ComputedPropertyName node
fn getPropertyNamePatched(node: PropertyName) -> string {
    if (isIdentifier(Node {id: node.id})) {
        let (name = node.getText()) {
            return name
        }
    }
    if (isPrivateIdentifier(Node {id: node.id})) {
        let (name = node.getText()) {
            return name
        }
    }
    // StringLiteral or NumericLiteral
    for (literalExpression in LiteralExpression(__all_data__)) {
        if (literalExpression.key_eq(node)) {
            let (name = literalExpression.getValue()) {
                return name
            }
        }
    }
    if (isComputedPropertyName(Node {id: node.id})) {
        return "<computed>"
    }
}

/**
 * This function checks whether the file contains certain ImportDeclarations (ESM style only).
 *
 * @param importFrom - The `xxx` of `from 'xxx'`
 * @param importSyntax - 0 for `import xxx`; 1 for `import {xxx}`
 * @param importName - The `xxx` of `import {xxx}` (Only needed if importSyntax=1)
 *
 * @return The local name of an import. Would be:
 *   * `xxx` of `import xxx`
 *   * `xxx` of `import {xxx}`
 *   * `yyy` of `import {xxx as yyy}` (Ignores the situation where `xxx` is a StringLiteral)
 */
fn getLocalImportName(db: JavascriptDB, file: File, importFrom: string, importSyntax: int, importName: string) -> string {
    for (importDeclaration in ImportDeclaration(db), importClause in ImportClause(db)) {
        if (file = importDeclaration.getLocation().getFile() &&
            importDeclaration.getLastChild().to<StringLiteral>().getValue() = importFrom &&
            importDeclaration.key_eq(importClause.getParent())
        ) {
            for (child in importClause.getAChild()) {
                // Import using ImportClause.name (Identifier)
                //                                             v This is only for not throwing ungrounded error
                if (importSyntax = 0 && isIdentifier(child) && importName = "-") {
                    return child.to<Identifier>().getName()
                }

                // Import using ImportClause.nameBindings (NamedImports)
                if (importSyntax = 1 && isNamedImports(child)) {
                    for (importSpecifier in ImportSpecifier(db)) {
                        if (child.key_eq(importSpecifier.getParent())) {
                            match(importSpecifier.getChildCount()) {
                                // `import {xxx}`
                                1 => let (name = importSpecifier.getChild(0)) {
                                    if (isIdentifier(name) && 
                                        name.to<Identifier>().getName() = importName
                                    ) {
                                        return importName
                                    }
                                },

                                // `import {xxx as yyy}`
                                2 => let (name0 = importSpecifier.getChild(0), name1 = importSpecifier.getChild(1)) {
                                    if (isIdentifier(name0) &&
                                        isIdentifier(name1) &&
                                        name0.to<Identifier>().getName() = importName
                                    ) {
                                        return name1.to<Identifier>().getName()
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Returns an array starting from the parent node, then its parent, ..., until the file node
fn getNodePath(node: Node) -> *Node {
    let (parent = node.getParent()) {
        yield parent

        for (upper in getNodePath(parent)) {
            yield upper
        }
    }
}
